<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Segundo corte</title>

    <link rel="preload" href="styles.css" as="style">
    <link rel="stylesheet" href="styles.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand&display=swap" rel="stylesheet">

</head>

<body>

    <header>

        <nav class="nav">
            <div class="nav_info">
                <li>
                    <a href="index.html">
                        <h1 class="nav_git">Pagina personal <span class="nav_nombre">Lenguajes de
                                Programación</span>
                        </h1>
                    </a>
                </li>
            </div>
            <ul class="">
                <div class="nav_enlaces">
                    <li class="nav_opciones">
                        <a href="index.html">Inicio</a>
                    </li>
                    <p class="separador">/</p>

                    <li class="nav_opciones">
                        <a href="curso.html">Curso</a>
                    </li>
                    <p class="separador">/</p>

                    <li class="nav_opciones has-dropdown" id="academico-dropdown">
                        <a href="#">Cortes</a>
                        <div class="dropdown-content">
                            <a href="primerc.html">Primer corte</a>
                            <a href="segundoc.html">Segundo corte</a>
                            <a href="tercerc.html">Tercer corte</a>

                        </div>
            </ul>
        </nav>
    </header>
    <section class="temas">
        <h1>Temas Vistos en el Segundo Corte</h1>
        <ul>
            <li><strong>
                    <h2>P.O.O en Python:</h2>
                </strong>
                <p class="temas-texto">
                    La programación orientada a objetos (POO) en Python es una forma de escribir programas
                    que se centra en objetos. Un objeto en Python es como un paquete que contiene datos
                    y acciones que puede realizar. Estos objetos se crean a partir de clases, que son como
                    moldes que definen cómo debe ser un objeto.
                    <br>
                    La POO se basa en cuatro conceptos importantes:
                    <br>
                    <strong>Abstracción:</strong> Crear clases y objetos que agrupan datos y funciones relacionadas.
                    <br>
                    <strong>Encapsulación:</strong> Ocultar los detalles internos de cómo se implementa una clase y
                    permitir el acceso solo a través de métodos.
                    <br>
                    <strong>Herencia:</strong> Permite que una clase herede características de otra clase.
                    <br>
                    <strong>Polimorfismo:</strong> Permite que un objeto se comporte de diferentes maneras.
                </p>
            </li>

            <li><strong>
                    <h2>¿Porque utilizar P.O.O?</h2>
                </strong>

                <p class="temas-texto">La Programación Orientada a Objetos proporciona varias ventajas que
                    hacen que sea una elección valiosa al desarrollar software. </p>
                <p class="temas-texto">
                    <strong>Software Modular: </strong>
                    <br>POO facilita la creación de software modular, dividiendo el código en módulos o clases.
                    Cada clase representa una entidad específica con sus propios datos y funcionalidades.
                    <br><strong> Beneficios:</strong>
                <p class="poo"><strong> Organización:</strong> Las clases permiten organizar el código de
                    manera más clara y comprensible.
                    <br><strong> Mantenimiento:</strong> Cambiar o actualizar una parte del software se vuelve más
                    manejable al tener módulos bien definidos.
                </p>
                </p>

                <p class="temas-texto">
                    <strong>Reutilizable: </strong>
                    <br>La reutilización de código es una característica clave de POO. Puedes crear clases y
                    luego reutilizarlas en diferentes partes de tu programa o incluso en proyectos diferentes.
                    <br><strong> Beneficios:</strong>
                <p class="poo"><strong> Eficiencia:</strong> No es necesario volver a escribir código similar cada vez.
                    Se reutilizan clases existentes, lo que ahorra tiempo y esfuerzo.
                    <br><strong> Consistencia:</strong> La reutilización promueve la consistencia en el
                    software, ya que las mismas clases se utilizan en diferentes contextos.
                </p>
                </p>

                <p class="temas-texto">
                    <strong>Adaptable: </strong>
                    <br>POO facilita la adaptación del software a cambios y evolución. Las clases pueden
                    modificarse o extenderse sin afectar otras partes del programa.
                    <br><strong> Beneficios:</strong>
                <p class="poo"><strong> Escalabilidad:</strong> A medida que los requisitos cambian, las clases
                    pueden modificarse o nuevas clases pueden agregarse sin afectar el resto del código.
                    <br><strong> Facilidad de Mantenimiento:</strong> La adaptabilidad simplifica el mantenimiento
                    a lo largo del tiempo, ya que el software puede evolucionar de manera más fluida.
                </p>
                </p>
            </li>

            <li><strong>
                    <h2>Patrones de diseño</h2>
                </strong>
                <p class="temas-texto">Los patrones de diseño son soluciones probadas y comunes a problemas
                    recurrentes en el diseño de software. Estas soluciones son esencialmente plantillas que
                    los desarrolladores pueden adaptar a sus propios problemas de diseño. Los patrones de
                    diseño no son códigos o bibliotecas específicas, sino más bien conceptos generales que
                    ayudan a estructurar y organizar el código de manera eficiente y mantenible.
                </p>
                <p class="temas-texto">
                    <strong>Patrones creacionales:</strong> Trata sobre la creación de objetos y aborda los
                    detalles relacionados con la creación, inicialización y representación de objetos. Ejemplos
                    de patrones creacionales incluyen el patrón Singleton, el método de fábrica (Factory Method)
                    y la fábrica abstracta (Abstract Factory). Estos patrones ofrecen soluciones estandarizadas
                    y flexibles para la creación de objetos, proporcionando un enfoque eficiente y estructurado
                    en el diseño de software.
                <p class="poo"><strong>singleton</strong>El patrón Singleton garantiza que una clase tenga
                    una única instancia y proporciona un punto de acceso global a esa instancia. En otras
                    palabras, asegura que solo exista una única instancia de la clase y proporciona un medio
                    para acceder a ella desde cualquier parte del programa.</p>
                </p>
                <pre><code>
                    
                <strong> class ClassicSingleton:
                    
                        _instance_ = None
                    
                        def __init__(this):
                            raise RuntimeError("invocar la función create_instance para crear objeto")
                        
                        def enqueueDocument(this, fileName, format):
                            pass
                    
                        def dispatchDocument(this, fileName):
                            pass
                    
                        def deleteDocument(this, fileName):
                            pass
                        
                        @classmethod
                        def createInstance(this):
                            if this._instance_ is None:
                                #lo hace solo una vez, cuando no se ha instanciado ningún objeto
                                this._instance_ = this.__new__(this) 
                                #__new__ lo usa internamente __init__ para crear una nueva instancia de clase
                            
                            return this._instance_
                    
                    printerPool1 = ClassicSingleton.createInstance() 
                                                                     
                    printerPool2 = ClassicSingleton.createInstance()
                    
                    print(printerPool1)
                    print(printerPool2)
                    
                    print(printerPool1 == printerPool2)</strong> 
                    
                    </code></pre>
                <p class="poo">El codigo anterior implementael singleton definiendo la variable de
                    <strong> clase _instance_</strong> que almacenará la única instancia de la clase <strong>
                        ClassicSingleton</strong> .
                    Inicialmente es None. El método <strong> __init__ </strong> lanza una excepción si se intenta usar
                    para
                    crear una instancia, forzando a usar el método de clase createInstance. Este método
                    verifica si <strong>_instance_</strong> es None, en cuyo caso crea la instancia única llamando
                    <strong> a __new__</strong> . Si ya existe una instancia, simplemente la retorna. De esta manera se
                    garantiza
                    que siempre es la misma instancia de <strong> ClassicSingleton</strong> la que se retorna al llamar
                    createInstance, logrando el objetivo del patrón Singleton de tener solo una instancia y
                    proporcionar acceso global a ella.
                </p>

                <p class="temas-texto">
                    <strong>Patrones estructurales:</strong> Estos patrones se centran en la organización de
                    objetos y sus relaciones para construir estructuras más grandes y complejas. Ejemplos de
                    patrones estructurales incluyen el patrón Adapter, el patrón Decorator y el patrón Composite.
                    Estos patrones proporcionan soluciones flexibles para mejorar la composición y la colaboración
                    entre objetos, permitiendo la construcción de sistemas más escalables y mantenibles.
                </p>
                <p class="poo"><strong>Adapter: </strong>Facilita la colaboración entre interfaces incompatibles,
                    permitiendo que trabajen juntas de manera armoniosa.</p>
                <pre><code>
                    
                    <strong>class Pdf_reader:
                        def request(self) -> str:
                            return "Lector: Lector PDF predeterminado"

                    class Document_word:
                        def specific_request(self) -> str:
                            return "parcial_2.docx"

                    class Adapter(Pdf_reader, Document_word):

                    def request(self) -> str:
                            string = self.specific_request().replace(".docx", ".pdf") 
                            return f"Documento cambiado: {string}"

                    def client_code(lector: "Pdf_reader") -> None:
                        print(lector.request())

                    if __name__ == "__main__":

                        print("Client: Sólo trabajo con documentos pdf:")
                        lector = Pdf_reader() #target
                        client_code(lector) 
                        print("\n")

                        adaptee = Document_word() #adaptada
                        print("Client: Este documento no es un pdf\n"
                            "Mira, no puedo leerlo:")
                        print(f"Document: {adaptee.specific_request()}")

                        print("Client: Puedo cambiar el formato de este documento:")
                        
                        adapter = Adapter()
                        client_code(adapter)</strong>

                </code></pre>
                <p class="poo">En el codigo anterior el patrón Adapter permite que la clase Adapter actúe
                    como un puente entre el código del cliente que espera la interfaz de <strong>Pdf_reader</strong> y
                    la
                    funcionalidad específica de <strong>Document_word</strong>. El Adapter utiliza la funcionalidad
                    específica (<strong>specific_request</strong>) de la clase Adaptada para proporcionar la interfaz
                    esperada por el cliente . En este caso, el Adapter cambia
                    el formato del documento adaptando la funcionalidad de <strong>Document_word</strong> para que sea
                    compatible con la interfaz de <strong>Pdf_reader</strong>.</p>

                <p class="temas-texto">
                    <strong>Patrones de comportamiento:</strong> Estos patrones de comportamiento se dedican a
                    gestionar la interacción dinámica entre objetos y clases en un sistema de software. Se ocupan
                    de cómo los objetos colaboran y se comunican entre sí durante la ejecución del programa.
                    Ejemplos de patrones de comportamiento incluyen el strategy, observer y command.
                </p>
                <p class="poo"><strong>strategy: </strong>El patrón Strategy define una familia de algoritmos,
                    encapsula cada uno de ellos y los hace intercambiables. Permite que el algoritmo varíe de forma
                    independiente de los clientes que lo utilizan.</p>
                <pre><code>

                    <strong>Strategy:
                        def execute():
                            pass
                    
                    class ConcreteStrategyA(Strategy):
                        def execute(self):
                            print ("Ejecutando estrategia concreta A")
                    
                    class ConcreteStrategyB(Strategy):
                        def execute(self):
                            print("Ejecutando estrategia concreta B")
                    
                    class Context:
                        def __init__(self,strategy:Strategy):
                            self.strategy = strategy
                    
                        def execute_strategy(self):
                            self.strategy.execute()
                    

                    strategyA = ConcreteStrategyA()
                    contexto_str1 = Context(strategyA)
                    result_str1 = contexto_str1.execute_strategy()
                    
                    strategyB = ConcreteStrategyB()
                    contexto_str2 = Context(strategyB)
                    result_str2 = contexto_str2.execute_strategy()</strong> 
                </code></pre>
                <p class="poo">En este código se define una interfaz Strategy genérica con el método execute().
                    Luego se crean dos estrategias concretas (<stronge>ConcreteStrategyA</stronge> y <stronge>
                        ConcreteStrategyB</stronge>) que implementan <stronge>execute()</stronge> de diferente forma. La
                    clase Context se inicializa con una estrategia
                    concreta pasada a su constructor. Su método <stronge>execute_strategy()</stronge> sirve de puente
                    para ejecutar
                    el algoritmo contenido en la estrategia con la que se inicializó. De esta forma el código
                    cliente que utiliza Context puede cambiar transparentemente la estrategia utilizada, sin
                    necesidad de modificaciones. Simplemente creando una nueva estrategia concreta y pasándola
                    a un Context. Esto permite variar el algoritmo ejecutado por Context de manera sencilla
                    según sea necesario.</p>

                <p class="poo"><strong>Observer: </strong>El patrón Observer permite definir una dependencia de
                     tipo "uno a muchos" entre objetos, de manera que cuando un objeto (el sujeto) cambia de 
                     estado, automáticamente notifica este cambio a todos los objetos que dependen de él (los 
                     observadores).</p>
                <pre><code>
                <strong># Alerta meteorológica. 
                    #Un servicio de alertas notifica a sus subscriptores sobre cambios 
                    ##drásticos en el clima (disminución de temperatura, lluvia repentina, vientos extremos, etc.)
                    
                    
                    # Interfaz para la estrategia de notificación
                    class NotificationStrategy:
                        def notify(self, message):
                            pass
                    
                    # Estrategia de notificación por defecto
                    class DefaultNotification(NotificationStrategy):
                        def notify(self, message):
                            print(f"Notificación por alerta meteorológica: {message}")
                    
                    # Estrategia de notificación para suscriptores
                    class SubscriberNotification(NotificationStrategy):
                        def __init__(self, subscriber_name):
                            self.subscriber_name = subscriber_name
                    
                        def notify(self, message):
                            print(f"{self.subscriber_name} recibió la notificación: {message}")
                    
                    class SubscriberObserver:
                        def __init__(self, subscriber, notification_strategy):
                            self.subscriber = subscriber
                            self.notification_strategy = notification_strategy
                    
                        def notify(self, message):
                            self.notification_strategy.notify(message)
                    
                    # Clase que realiza la notificación
                    class Notifier:
                        def __init__(self, notification_strategy):
                            self.notification_strategy = notification_strategy
                    
                        def notify(self, message):
                            self.notification_strategy.notify(message)
                    
                    if __name__ == "__main__":
                        #Crearestrategias de notificación
                        default_notification = DefaultNotification()
                        subscriber1_notification = SubscriberNotification("Suscriptor 1")
                        subscriber2_notification = SubscriberNotification("Suscriptor 2")
                        subscriber3_notification = SubscriberNotification("Suscriptor 3")
                    
                        subscriber1_Observer = SubscriberObserver(subscriber1_notification, subscriber1_notification)
                        subscriber2_Observer = SubscriberObserver(subscriber2_notification, subscriber2_notification)
                        subscriber3_Observer = SubscriberObserver(subscriber3_notification, subscriber3_notification)
                    
                        #Crear un notificador con la estrategia por defecto
                        notifier = Notifier(default_notification)
                    
                        #Notificar a los suscriptores
                        notifier.notify("Cambios drásticos en el clima. ")
                        subscriber1_Observer.notify("Notificación alerta meteorológica: Disminucion de temperatura.")
                        subscriber2_Observer.notify("Notificación alerta metoorologica: Lluvia repentina.")
                        subscriber3_Observer.notify("Notificacion alerta meteorologica: Vientos extremos.")</strong>
                    
                    </code></pre>
                <p class="poo">El patrón Observer en este código desacopla la lógica de notificación meteorológica entre 
                    el sujeto Notifier que emite las notificaciones y los observadores <strong>SuscriberObserver</strong> 
                    que las reciben, permitiendo agregar suscriptores nuevos y configurar fácilmente la strategia de 
                    notificación de cada uno sin afectar al <strong>Notifier</strong>; esto se logra definiendo una interfaz 
                    de notificación <strong>NotificationStrategy</strong> y haciendo que el <strong>Notifier</strong> y cada 
                    <strong>SuscriberObserver</strong> tengan su propia strategia, de forma que cuando el <strong>Notifier
                    </strong> emite una notificación utilizando su strategia, cada <strong>SuscriberObserver</strong> la 
                    recibe y procesa de manera desacoplada según su propia strategia configurada.</p>
            </li>


    </section>


</body>


</html>